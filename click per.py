# -*- coding: utf-8 -*-
"""Click prediction POC.ipynb
it's a simplified project that offers how we can predict number of clicks some Sponsored Product Ads (SPA) receive on a brand, campaign, and product level.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12pZEZk1N12LBs6GHAga5VuzYME6vTQ2a


Date: The date of the ad.


Brand: The brand associated with the ad.

CampaignType: Type of the campaign (e.g., 'Seasonal', 'Product Launch').

AdSpend: Amount spent on the ad for that day.

Impressions: Number of times the ad was shown.

ProductType: Type of product being advertised.

DayOfWeek: Day of the week.

NumberofClicks: The target variable, number of clicks on the ad.
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import random
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline



# Define the number of samples
n_samples = 90

# Seed for reproducibility
np.random.seed(0)

# Generate the updated sample data with new brand names and product types
data = {
    "Date": pd.date_range(start="2023-01-01", periods=n_samples, freq='D'),
    "Brand": np.random.choice(["CHANEL", "KYLIE", "LA MER", "LA PRAIRIE", "DOLCE & GABBANA", "DIOR"], n_samples),
    "CampaignType": np.random.choice(["Seasonal", "Product Launch", "Brand Awareness"], n_samples),
    "AdSpend": np.random.uniform(500, 5000, n_samples),  # Random ad spend
    "Impressions": np.random.randint(1000, 10000, n_samples),
    "ProductType": np.random.choice(["Makeup", "Skin", "Perfume"], n_samples),
    "DayOfWeek": pd.date_range(start="2023-01-01", periods=n_samples, freq='D').dayofweek,
}

# Adding NumberofClicks based on AdSpend with a random component
# This is a simplified formula and may not reflect real-world complexities accurately
click_rate = 0.02
random_factor = np.random.uniform(0.5, 1.5, n_samples)  # Random factor to introduce variability
data["NumberofClicks"] = (data["AdSpend"] * click_rate * random_factor).astype(int)

df = pd.DataFrame(data)

# Extract numerical features from the 'Date' column
df['Month'] = df['Date'].dt.month
df['DayOfMonth'] = df['Date'].dt.day
df['Year'] = df['Date'].dt.year

# Drop the original 'Date' column
df.drop('Date', axis=1, inplace=True)

df.head()

# Split the data into training and test sets
X = df.drop("NumberofClicks", axis=1)
y = df["NumberofClicks"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

# Define the transformer for one-hot encoding
categorical_features = ['Brand', 'CampaignType', 'ProductType']
one_hot = OneHotEncoder()
transformer = ColumnTransformer([("one_hot", one_hot, categorical_features)], remainder="passthrough")

# Define the Random Forest model within a pipeline
rf_model = Pipeline(steps=[('preprocessor', transformer),
                           ('regressor', RandomForestRegressor(n_estimators=100, random_state=0))])

# Define a new Random Forest model within a pipeline
rf_model = Pipeline(steps=[('preprocessor', transformer),
                           ('regressor', RandomForestRegressor(n_estimators=100, random_state=0))])

# Train the Random Forest model
rf_model.fit(X_train, y_train)

# Predict on the test set and evaluate
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
mse

# Extracting feature importances from the model
feature_importances = rf_model.named_steps['regressor'].feature_importances_

# Getting feature names after one-hot encoding
encoded_feature_names = rf_model.named_steps['preprocessor'].transformers_[0][1].get_feature_names_out(categorical_features)
remaining_feature_names = X.columns.drop(categorical_features)
all_feature_names = np.concatenate([encoded_feature_names, remaining_feature_names])

# Creating a DataFrame to display feature importances
feature_importance_df = pd.DataFrame({
    'Feature': all_feature_names,
    'Importance': feature_importances
}).sort_values(by='Importance', ascending=False)

feature_importance_df

# Example features for a hypothetical Dior campaign
example_data = {
    'Brand': ['DIOR'],
    'CampaignType': ['Product Launch'],  # Replace with actual campaign type
    'AdSpend': [3000],  # Example ad spend, replace with actual value
    'Impressions': [7000],  # Example impressions, replace with actual value
    'ProductType': ['Perfume'],  # Replace with actual product type
    'DayOfWeek': [2],  # Example day of the week (0 = Monday, 6 = Sunday)
    'DayOfMonth': [15],  # Example day of the month
    'Month': [6],  # Example month (June)
    'Year': [2023]  # The year of the campaign
}


example_df = pd.DataFrame(example_data)

# Preprocess the input data
processed_example = rf_model.named_steps['preprocessor'].transform(example_df)

# Predict the number of clicks
predicted_clicks = rf_model.named_steps['regressor'].predict(processed_example)
predicted_clicks[0]  # Display the predicted number of clicks

"""Now let's look at the problem from a different perspective, let's say we want to have a campaign if and only if the ROI is positive. So how we can predict number of clicks based of this assumption?

Average Revenue per Click (ARPC): This is a hypothetical value representing the average revenue generated from each click. In a real-world scenario, this would be derived from detailed historical sales and conversion data.

Desired ROI: This is the minimum ROI a campaign should achieve to be considered. For simplicity, we'll use a uniform ROI target across all data points. In a more complex model, this could vary based on different factors like campaign type, brand, etc.
"""

# Adding Average Revenue per Click (ARPC) and Desired ROI
# ARPC is randomly generated
# Desired ROI is set as a constant for simplicity (e.g., 0.2 for 20% ROI)

np.random.seed(0)
arpc = np.random.uniform(0.5, 2.0, n_samples)  # Simulating a range of revenue per click
desired_roi = 0.2  # 20% ROI

df['ARPC'] = arpc
df['DesiredROI'] = desired_roi

"""Minimum Clicks for Positive ROI=⌈
ARPC
Ad Spend×(1+Desired ROI)/ARPC
​
 ⌉
"""

# Calculate the minimum number of clicks needed for positive ROI
# Formula: Min Clicks = (AdSpend * (1 + DesiredROI)) / ARPC
df['MinClicksForPositiveROI'] = (df['AdSpend'] * (1 + df['DesiredROI'])) / df['ARPC']
df['MinClicksForPositiveROI'] = df['MinClicksForPositiveROI'].apply(np.ceil)  # Round up to nearest whole number

df[['Brand', 'AdSpend', 'ARPC', 'DesiredROI', 'MinClicksForPositiveROI']].head()  # Display the new columns

"""# **Additionally, what non-campaign and non-ecom data could be brought in to strengthen the model?**

Consumer Behavior Data like:


Clickstream Data

Search Query Logs

and
Demographic information of the target audience, like age, gender, income levels.

External Events

Major events

Geographical Data
"""

